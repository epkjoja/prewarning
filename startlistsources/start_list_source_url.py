# -*- coding: utf-8 -*-

import logging
from threading import Thread
from time import sleep
from typing import List, Dict
from xml.etree import ElementTree
from urllib.error import HTTPError, URLError
from urllib.request import Request, urlopen
from imurl import URL

from natsort import natsorted

from utils.config import ConfigSectionDefinition, ConfigOptionDefinition, Config
from utils.config_definitions import ConfigSectionEnableType
from validators.url_validators import is_url
from ._base import _StartListSourceBase


LOGGER_NAME = 'StartListSourceUrl'

DEFAULT_RESPONSE_ENCODING = 'utf-8'


def _get_data(element, selector, ns):
    data = element.find(selector, ns)
    if data is not None:
        return data.text
    else:
        return None


class StartListSourceUrl(_StartListSourceBase):
    """
    A Start List Source that reads an IOF XML v3 start list repeatedly from a URL.
    """

    name = __qualname__

    display_name = 'URL Start List Source'

    description = 'Reads a start list file following the ' \
                  '<a href="https://orienteering.sport/iof/it/data-standard-3-0/">IOF 3.0 Data Standard</a> ' \
                  'and uses it to look up the team bib number and relay leg. ' \
                  'Files generated by <a href="https://www.svenskorientering.se/Arrangera/itochtavlings-' \
                  'administration/OLAtidtagnings-program/">OLA</a>, ' \
                  '<a href="https://sportsoftware.de/orienteering/os">OS2010</a> and '\
                  '<a href="https://www.melin.nu/meos/">MeOS</a> have been tested.' \
                  'The URL will be re-fetched with a configurable interval.'

    CONFIG_OPTION_START_LIST_URL = ConfigOptionDefinition(
        name='StartListUrl',
        display_name='Start List URL',
        value_type=str,
        description='The URL that will return the start list.',
        mandatory=True,
        validator=is_url,
    )

    CONFIG_OPTION_START_LIST_RELOAD_INTERVAL = ConfigOptionDefinition(
        name='StartListReloadInterval',
        display_name='Start List Reload interval (minutes)',
        value_type=int,
        description='The interval with which the start list will be re-fetched from the URL.',
        mandatory=True,
        default_value=5,
    )

    START_LIST_SOURCE_URL_CONFIG_SECTION_DEFINITION = ConfigSectionDefinition(
        name=name,
        display_name=display_name,
        option_definitions=[
            CONFIG_OPTION_START_LIST_URL,
            CONFIG_OPTION_START_LIST_RELOAD_INTERVAL,
        ],
        enable_type=ConfigSectionEnableType.IF_ENABLED,
        sort_key_prefix=50,
    )

    Config.register_config_section_definition(START_LIST_SOURCE_URL_CONFIG_SECTION_DEFINITION)

    @classmethod
    def config_section_definition(cls) -> ConfigSectionDefinition:
        return cls.START_LIST_SOURCE_URL_CONFIG_SECTION_DEFINITION

    def __repr__(self) -> str:
        return f'StartListSourceUrl(running={self._running},' \
               f' start_list_url={self.start_list_url},' \
               f' start_list_reload_interval={self.start_list_reload_interval})'

    def __str__(self) -> str:
        return repr(self)

    def __init__(self):
        if LOGGER_NAME != self.__class__.__name__:
            raise ValueError('LOGGER_NAME not correct: {} vs {}'.format(LOGGER_NAME, self.__class__.__name__))

        self.logger = logging.getLogger(self.__class__.__name__)

        super().__init__()

        self.start_list_url = None
        self.start_list_reload_interval = 5

        self.team_names = dict()
        self.teams = dict()
        self.runners = dict()

        self._running = False

        self.update()
        self.logger.debug(self)

        self.start_list_fetcher = Thread(target=self._read_start_list, daemon=True, name='StartListUrlFetcherThread')

    def __del__(self):
        self.stop()

    def start(self):
        self._running = True
        self.start_list_fetcher.start()

    def stop(self):
        self._running = False
        if self.start_list_fetcher.is_alive():
            self.start_list_fetcher.join()

    def is_running(self) -> bool:
        return self._running

    def get_config_section_definitions(self) -> List[ConfigSectionDefinition]:
        """Returns a list of configuration section definitions.

        :return: A list of configuration section definitions
        :rtype: List[ConfigSectionDefinition]
        """
        definitions = super().get_config_section_definitions()
        definitions.append(self.START_LIST_SOURCE_URL_CONFIG_SECTION_DEFINITION)
        return definitions

    def config_updated(self, section_names: List[str]):
        self.update()

    def update(self):
        self._parse_config()
        self._read_start_list()

    def _parse_config(self):
        config_section = Config().get_section(self.name)

        self.start_list_url = self.CONFIG_OPTION_START_LIST_URL.get_value(config_section)
        self.start_list_reload_interval = self.CONFIG_OPTION_START_LIST_RELOAD_INTERVAL.get_value(config_section)

    def _read_start_list(self):
        self.logger.debug('Started')

        while self._running:
            url = URL(self.start_list_url)
            req = Request(url.url)

            self.logger.debug('Url is %s', url.url)

            try:
                response = urlopen(req)
                response_encoding = response.info().get_content_charset()
                if response_encoding is None:
                    response_encoding = DEFAULT_RESPONSE_ENCODING

                data = response.read().decode(response_encoding)
            except HTTPError as e:
                logging.getLogger(LOGGER_NAME).error(
                    '_read_start_list: The server could not fulfill the request. Error code: %s', e.code)
                raise
            except URLError as e:
                logging.getLogger(LOGGER_NAME).error(
                    '_read_start_list: We failed to reach a server. Reason: %s', e.reason)
                raise
            except Exception as e:
                logging.getLogger(LOGGER_NAME).error('_read_start_list: Unknown Exception. %s', e)
                raise

            start_list = ElementTree.fromstring(data)

            if start_list.tag != '{http://www.orienteering.org/datastandard/3.0}StartList':
                self.logger.error('The Start List URL (%s) doesn\'t return a valid IOFv3 Start List.',
                                  self.start_list_url)
                raise ValueError('The Start List URL ({}) doesn\'t return a valid IOFv3 Start List.'.format(
                    self.start_list_url))

            ns = {'ns': 'http://www.orienteering.org/datastandard/3.0'}

            event_id = _get_data(start_list, 'ns:Event/ns:Id', ns)
            event_name = _get_data(start_list, 'ns:Event/ns:Name', ns)
            event_date = _get_data(start_list, 'ns:Event/ns:StartTime/ns:Date', ns)
            organiser_id = _get_data(start_list, 'ns:Event/ns:Organiser/ns:Id', ns)
            organiser_name = _get_data(start_list, 'ns:Event/ns:Organiser/ns:Name', ns)

            if event_date is not None:
                self.competition_date = event_date

            self.logger.debug('Event: %s (%s) %s', str(event_name), str(event_id), str(event_date))
            self.logger.debug('Organiser: %s (%s)', str(organiser_name), str(organiser_id))

            self.team_names.clear()
            self.teams.clear()
            self.runners.clear()

            xml_teams = start_list.findall('ns:ClassStart/ns:TeamStart', ns)
            for xml_team in xml_teams:
                team_name = _get_data(xml_team, 'ns:Name', ns)
                team_bib_number = _get_data(xml_team, 'ns:BibNumber', ns)
                self.team_names[team_bib_number] = team_name

                team = dict()
                team_members = xml_team.findall('ns:TeamMemberStart', ns)
                for team_member in team_members:
                    team_member_id = _get_data(team_member, 'ns:Person/ns:Id', ns)
                    team_member_name_family = _get_data(team_member, 'ns:Person/ns:Name/ns:Family', ns)
                    team_member_name_given = _get_data(team_member, 'ns:Person/ns:Name/ns:Given', ns)
                    team_member_leg = _get_data(team_member, 'ns:Start/ns:Leg', ns)
                    team_member_leg_order = _get_data(team_member, 'ns:Start/ns:LegOrder', ns)
                    team_member_bib_number = _get_data(team_member, 'ns:Start/ns:BibNumber', ns)
                    team_member_control_card = _get_data(team_member, 'ns:Start/ns:ControlCard', ns)
                    if team_member_control_card is not None:
                        self.runners[team_member_control_card] = {'id': team_member_id,
                                                                  'family': team_member_name_family,
                                                                  'given': team_member_name_given,
                                                                  'leg': team_member_leg,
                                                                  'leg_order': team_member_leg_order,
                                                                  'team_bib_number': team_bib_number,
                                                                  'bib_number': team_member_bib_number,
                                                                  'control_card': team_member_control_card}
                        if team_member_leg not in team:
                            team[team_member_leg] = dict()
                        leg = team[team_member_leg]
                        leg[team_member_leg_order] = self.runners[team_member_control_card]

                team = natsorted(team.items())
                self.teams[team_bib_number] = team
            # for leg in team.items():
            # 	for subleg in leg:
            #

            self.team_names = dict(natsorted(self.team_names.items()))
            self.teams = dict(natsorted(self.teams.items()))
            # self.start_list_file_time = stat(self.add_path(self.start_list_file)).st_mtime
            self.logger.debug('Teams: %s', str(self.team_names))
            self.logger.debug('Runners: %s', str(self.runners))

            self.logger.debug('Sleeping for %s minutes', str(self.start_list_reload_interval))
            sleep(self.start_list_reload_interval*60)

        self.logger.debug('Stopped')

    def lookup_from_card_number(self, card_number: str) -> Dict[str, str] or None:
        """Returns Bib-Number and Relay Leg for the provided Card Number.

        :param str card_number: The Card Number to look up.
        :return: A dict with the Bib-Number (bibNumber) and Relay Leg (relayLeg).
        :rtype: Dict[str, Str] or None
        """
        runner = self.runners.get(card_number)
        if runner is not None:
            team_bib_number = runner['team_bib_number']
            leg = runner['leg']
            return {'bibNumber': team_bib_number, 'relayLeg': leg}
        else:
            self.logger.warning('Not found: %s', card_number)
            return None
